/** * * * @author      P.J. Onori * @version     0.1 */package com.openflux.layout.organizers	{	import flash.display.*;	import com.openflux.layout.elements.Cell;	public class LayoutOrganizer	{				protected var _target:Sprite;		protected var _cells:Array;				protected var _x:Number;		protected var _y:Number;		protected var _width:Number;		protected var _height:Number;				protected var _tweenFunction:Function;				protected var _autoAdjust:Boolean;				public function set tweenFunction(value:Function):void		{			this._tweenFunction=value;		}				/**		 * Specifies whether layout properties (x, y, width, height, etc.) adjust the layout 		 * automatically without calling apply() method 		 *		 * @param  value   		 * @see    LayoutOrganizer#apply(Function tweenFunction)		 */		public function set autoAdjustLayout(value:Boolean):void		{			this._autoAdjust = value;		}				/**		* @return  Current setting of auto-adjust (defaults to false)   		 */		public function get autoAdjustLayout():Boolean		{			return this._autoAdjust;		}				/**		 * Returns the number of cells currently stored and managed		 *		 * @return  Total number of cells   		 */		public function get totalCells():uint		{			return (!_cells) ?0:this._cells.length;		}				/**		 * Returns an array of cell objects		 *		 * @return	Array containing all cell objects     		 */		public function get cells():Array		{			var c:Array = this._cells			return c;		}				/**		 * Accessor for layout x property		 *		 * @return	X position of layout organizer   		 */		public function get x():Number		{			return this._x;		}				/**		 * Accessor for layout y property		 *		 * @return	Y position of layout organizer   		 */		public function get y():Number		{			return this._y;		}				/**		 * Mutator for y property		 *		 * @param	value	Global Y position of layout organizer   		 */		public function set y(value:Number):void		{			this._y=value;			this.adjustLayout();			if(_autoAdjust) this.apply(_tweenFunction);		}				/**		 * Mutator for x property		 *		 * @param	value	Global X position of layout organizer   		 */			public function set x(value:Number):void		{			this._x=value;			this.adjustLayout();			if(_autoAdjust) this.apply(_tweenFunction);		}						/**		 * Accessor for layout width property		 *		 * @return	Width of layout organizer   		 */		public function get width():Number		{			return this._width;		}				/**		 * Accessor for layout height property		 *		 * @return	Height position of layout organizer   		 */		public function get height():Number		{			return this._height;		}				/**		 * Mutator for width property		 *		 * @param	value	Global width dimension of layout organizer   		 */		public function set width(value:Number):void		{			this._width=value;			this.adjustLayout();			if(_autoAdjust) this.apply(_tweenFunction);		}				/**		 * Mutator for height property		 *		 * @param	value	Global height dimension of layout organizer   		 */		public function set height(value:Number):void		{			this._height=value;			this.adjustLayout();			if(_autoAdjust) this.apply(_tweenFunction);		}						/**		 * Accessor for layout target		 *		 * @return	Display target of layout organizer   		 */		public function get target():Sprite		{			return _target;		}				/**		 *		 * @param  target  The object to contain all items managed by LayoutOrganizer		 */		public function LayoutOrganizer(target:Sprite):void		{			this._target=target;		}				/**		 * Returns cell object by specified display object		 *		 * @param  link  an absolute URL giving the base location of the image		 * @return      the cell object which the display object is linked to		 * @see         Cell		 */		public function getCellByLink(link:DisplayObject):Cell		{			for(var i:int;i<this._cells.length;i++)			{				if(this._cells[i].link==link) return this._cells[i];			}			return null;		}				/**		 * Returns specified cell object's index in the collection 		 *		 * @param  cell  cell object from layout organizer		 * @return      index of cell object in the collection of cells		 * @see         Cell		 */		public function getCellIndex(cell:Cell):uint		{			for(var i:uint=0; i<this._cells.length; i++)			{				if(this._cells[i]==cell) return i;			}			return null;		}				/**		 * Returns cell object at specified index of collection		 *		 * @param  index  index of item in the collection of cells		 * @return      cell object at the specified location in the collection		 * @see         Cell		 */		public function getCellAt(index:uint):Cell		{			return this._cells[index];		}				/**		 * Applies all layout property values to a specified index in the collection		 *		 * @param  item  display object 		 * @param  tweenFunction  function with a Cell parameter for managing the motion of the cell object		 */		public function applyAt(index:uint, tweenFunction:Function=null):void		{						if(tweenFunction!=null) tweenFunction(this._cells[index]);			else {				this._cells[index].link.x=this._cells[index].x;				this._cells[index].link.y=this._cells[index].y;			}		}				/**		 * Applies all layout property values to a specified cells/display objects in the collection		 *		 * @param  item  display object 		 * @param  tweenFunction  function with a Cell parameter for managing the motion of the cell object		 */		public function applyItem(item:DisplayObject, tweenFunction:Function=null):void		{			var cell:Cell = this.getCellByLink(item);						if(!cell) return;						if(tweenFunction!=null) tweenFunction(cell);			else {				cell.link.x=cell.x;				cell.link.y=cell.y;			}		}				/**		 * Applies all layout property values to all cells/display objects in the collection		 *		 * @param  tweenFunction  function with a Cell parameter for managing the motion of the cell object		 */		public function apply(tweenFunction:Function=null):void		{			var len:int = this._cells.length;			var c:Cell;			while(len--)			{				c = this._cells[len];				if(tweenFunction!=null) tweenFunction(c);				else if(_tweenFunction!=null) _tweenFunction(c);				else {					c.link.x=c.x, c.link.y=c.y;				}			}		}				/**		 * Swaps links of two cell objects		 *		 * @param  cellTo  		 * @param  cellFrom		 */		public function swapCellLinks(cellTo:Cell, cellFrom:Cell):void		{			var tmpLink:DisplayObject = cellTo.link;			cellTo.link = cellFrom.link;			cellFrom.link = tmpLink;			if(_autoAdjust) this.apply(_tweenFunction);			}				/**		 * Removes all links between cells and display objects 		 *		 */		public function removeLinks():void		{			for(var i:int=0; i<_cells.length; i++)			{				_cells[i].link=null;			}		}				/**		 * Removed the link between cell and display object at the specified index		 *		 * @param  index  index in collection of item to be removed		 */		public function removeLinkAt(index:uint):void		{			_cells[index].link=null;		}				/**		 * Removes specified Cell object from layout organizer		 *		 * @param  cell	specified Cell object to remove		 */		public function removeCell(cell:Cell):void		{			_cells.splice(getCellIndex(cell), 1);		}				/**		 * Adds a link between the specified display object to the cell object at the specified index		 *		 * @param  object	item to add to collection		 * @param  index		position where to add the item		 */		public function addLinkAt(object:DisplayObject, index:uint):void		{			_cells[index].link=object;		}						protected function getNextAvailableCell():Cell		{			for(var i:uint=0; i<this._cells.length; i++)			{				if(!this._cells[i].link) 				{					return this._cells[i];				}			}			return null;		}				protected function clearCells():void		{			if(this._cells)			{				for(var i:String in this._cells)				{					delete this._cells[i];					this._cells[i]=null;				}			}			this._cells=new Array();		}				protected function adjustLayout():void {}			}}