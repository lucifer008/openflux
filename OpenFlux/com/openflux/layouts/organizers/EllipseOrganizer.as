/** * * * @author      P.J. Onori * @version     0.1 */package com.openflux.layout.organizers	{	import flash.display.*;	import com.openflux.layout.elements.*;		public class EllipseOrganizer extends LayoutOrganizer implements ILayoutOrganizer	{				private var _rotation:Number=0;				/**		 * Accessor for eccentricity property		 *		 * @return	eccentricity  Eccentricity of ellipse  		 */		public function get eccentricity():Number		{			var a:Number = (_width>_height) ? _width/2:_height/2;			var b:Number = (_width>_height) ? _height/2:_width/2;			var e:Number = Math.sqrt(1-(Math.pow(b,2)/Math.pow(a,2)));						return e;		}				/**		 * Mutator for rotation property		 *		 * @param	value	Global rotation position of layout organizer   		 */		public function set rotation(value:Number):void		{			this._rotation=value;			this.adjustLayout();			if(_autoAdjust) this.apply(_tweenFunction);		}				public function get rotation():Number		{			return this._rotation;		}				/**		 * Constructor for EllipseOrganizer 		 *		 * @param  target  DisplayObject where all layout elements will reside		 * @param  width  total width of the entire ellipse		 * @param  height  total height of the entire ellipse		 * @param  xOffset  x position of ellipse		 * @param  yOffset  y position of ellipse		 * @param rotation  global rotation of ellipse organizer		 */		public function EllipseOrganizer(target:Sprite, width:Number, height:Number, xOffset:Number=0, yOffset:Number=0, rotation:Number=0):void		{			super(target);			this._cells = new Array();			this._width=width;			this._height=height;			this._x=xOffset;			this._y=yOffset;			this._rotation=rotation;		}				/**		 * Adds DisplayObject to layout in next available position		 *		 * @param  object  DisplayObject to add to organizer		 * @param  moveToCoordinates  automatically move DisplayObject to corresponding cell's coordinates		 * @param  addToStage  adds a child DisplayObject instance to target's DisplayObjectContainer instance		 */		public function addToLayout(object:DisplayObject,  moveToCoordinates:Boolean=true, addToStage:Boolean=true):void		{			var cell:EllipseCell = new EllipseCell(0,0,0,object);			this._cells.push(cell);						this.adjustLayout();						if(moveToCoordinates)			{				this.apply(_tweenFunction);			}			if(addToStage)			{				this._target.addChild(object);			}		}				/**		 * Applies all layout property values to a specified cells/display objects in the collection		 *		 * @param  item  display object 		 * @param  tweenFunction  function with a Cell parameter for managing the motion of the cell object		 */		public override function applyItem(item:DisplayObject, tweenFunction:Function=null):void		{			var cell:EllipseCell = this.getCellByLink(item) as EllipseCell;						if(!cell) return;						if(tweenFunction!=null) tweenFunction(cell);			else {				cell.link.x=cell.x;				cell.link.y=cell.y;				cell.link.rotation=cell.rotation;			}		}				/**		 * Applies all layout property values to all cells/display objects in the collection		 *		 * @param  tweenFunction  function with a Cell parameter for managing the motion of the cell object		 */		public override function apply(tweenFunction:Function=null):void		{			var len:uint = this._cells.length;			var c:EllipseCell;			for(var i:int=0; i<len; i++)			{				if(tweenFunction!=null) tweenFunction(this._cells[i]);				else if(_tweenFunction!=null) _tweenFunction(this._cells[i]);				else {					c=this._cells[i]					c.link.x=c.x;					c.link.y=c.y;					c.link.rotation=c.rotation;				}			}		}				/**		 * Removes specified cell and its link from layout organizer and adjusts layout appropriately		 *		 * @param  cell  cell object to remove		 */		public override function removeCell(cell:Cell):void		{			super.removeCell(cell);			this.adjustLayout();			if(_autoAdjust) this.apply(_tweenFunction);		}				/**		 * Returns angle of position of specified cell in degrees 		 *		 * @param  cell  cell object		 */		public function getCellAngle(cell:Cell):Number		{			var xR:Number = cell.link.x-(_x+_width/2);			var yR:Number = cell.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			var a:Number = rads*(180/Math.PI)+90;						return a;		}				/**		 * Sets angle of position of specified cell in degrees 		 *		 * @param  cell  cell object		 * @param  angle angle of cell in degrees		 */		public function setCellAngle(cell:Cell, angle:Number):void		{			var angle:Number = getCellAngle(cell);			this.rotation=this.rotation-angle;		}				/**		* Clones the current object's properties (does not include links to DisplayObjects)		* 		* @return EllipseOrganizer clone of object		*/		public function clone():EllipseOrganizer		{			return new EllipseOrganizer(_target, _width, _height, _x, _y, _rotation);		}						/*PRIVATE METHODS		-------------------------------------------------*/				protected override function adjustLayout():void		{			var len:int=this._cells.length;			var w:Number = this._width/2;			var h:Number = this._height/2;			var rOffset:Number = _rotation*(Math.PI/180);			var rad:Number;			var c:EllipseCell;			for(var i:int=0; i<len; i++)			{					c = this._cells[i];				rad = ((Math.PI*(i))/(len/2))+rOffset;												c.x = (w*Math.cos(rad))+(w+_x);				c.y = (h*Math.sin(rad))+(h+_y);			}		}				/**		 * Moves all elements along the eliptical path so that the specified cell is at the top of the ellipse		 *		 * @param  cell  cell object to move		 */		private function rotateCellToTop(cell:Cell):Number		{			var xR:Number = cell.link.x-(_x+_width/2);			var yR:Number = cell.link.y-(_y+_height/2);						var rads:Number = Math.atan2(yR*(_width/_height), xR);			//rotation of individual object			var a:Number = rads*(180/Math.PI)+90;						this.rotation=rotation-a;			return a;		}	}}